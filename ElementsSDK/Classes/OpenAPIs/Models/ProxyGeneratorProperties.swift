//
// ProxyGeneratorProperties.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct ProxyGeneratorProperties: Codable, JSONEncodable, Hashable {

    public var supportsVideoBitrate: Bool?
    public var supportsVideoCrf: Bool?
    public var supportsVideoVbr: Bool?
    public var supportsAudioBitrate: Bool?
    public var supportsLut: Bool?
    public var supportsResolution: Bool?
    public var supportsWatermark: Bool?
    public var supportsTimecodeBurnIn: Bool?
    public var supportsAudioChannels: Bool?
    public var supportsStagingPath: Bool?

    public init(supportsVideoBitrate: Bool? = nil, supportsVideoCrf: Bool? = nil, supportsVideoVbr: Bool? = nil, supportsAudioBitrate: Bool? = nil, supportsLut: Bool? = nil, supportsResolution: Bool? = nil, supportsWatermark: Bool? = nil, supportsTimecodeBurnIn: Bool? = nil, supportsAudioChannels: Bool? = nil, supportsStagingPath: Bool? = nil) {
        self.supportsVideoBitrate = supportsVideoBitrate
        self.supportsVideoCrf = supportsVideoCrf
        self.supportsVideoVbr = supportsVideoVbr
        self.supportsAudioBitrate = supportsAudioBitrate
        self.supportsLut = supportsLut
        self.supportsResolution = supportsResolution
        self.supportsWatermark = supportsWatermark
        self.supportsTimecodeBurnIn = supportsTimecodeBurnIn
        self.supportsAudioChannels = supportsAudioChannels
        self.supportsStagingPath = supportsStagingPath
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case supportsVideoBitrate = "supports_video_bitrate"
        case supportsVideoCrf = "supports_video_crf"
        case supportsVideoVbr = "supports_video_vbr"
        case supportsAudioBitrate = "supports_audio_bitrate"
        case supportsLut = "supports_lut"
        case supportsResolution = "supports_resolution"
        case supportsWatermark = "supports_watermark"
        case supportsTimecodeBurnIn = "supports_timecode_burn_in"
        case supportsAudioChannels = "supports_audio_channels"
        case supportsStagingPath = "supports_staging_path"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(supportsVideoBitrate, forKey: .supportsVideoBitrate)
        try container.encodeIfPresent(supportsVideoCrf, forKey: .supportsVideoCrf)
        try container.encodeIfPresent(supportsVideoVbr, forKey: .supportsVideoVbr)
        try container.encodeIfPresent(supportsAudioBitrate, forKey: .supportsAudioBitrate)
        try container.encodeIfPresent(supportsLut, forKey: .supportsLut)
        try container.encodeIfPresent(supportsResolution, forKey: .supportsResolution)
        try container.encodeIfPresent(supportsWatermark, forKey: .supportsWatermark)
        try container.encodeIfPresent(supportsTimecodeBurnIn, forKey: .supportsTimecodeBurnIn)
        try container.encodeIfPresent(supportsAudioChannels, forKey: .supportsAudioChannels)
        try container.encodeIfPresent(supportsStagingPath, forKey: .supportsStagingPath)
    }
}

